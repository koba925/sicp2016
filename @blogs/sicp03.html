<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<title>sicp03</title>



</head>

<body>

<h1 id="toc_0">SICPを読む(3)</h1>

<h2 id="toc_1">1.2 Procedures and the Processes They Generate</h2>

<ul>
<li>基本的なプログラムの構成要素について学んできたがそれだけでは充分ではない</li>
<li>さまざまなタイプの手続きによって生成されるプロセスを予測する能力が必要</li>
</ul>

<p>何度も強調されてます<br>
自分はちょっと書いてみてすぐ動かしてああうまくいった（あるいはうまくいかない）、的に<br>
やることが多いので刺さります<br>
いやだって頭のなかで考えるのが苦手で・・・<br>
つまり素質が<br>
いやいや</p>

<ul>
<li>手続きは、直前の段階に基づいて次の段階をどのように作り出すかを指定する</li>
<li>そして、段階の積み重ねが全体としてどのようなふるまいになるのかを知りたい</li>
</ul>

<p>深いことが書いてあるようなそうでもないような<br>
いつか真の意味がわかる、みたいなときが来るんでしょうか</p>

<h2 id="toc_2">1.2.1 Linear Recursion and Iteration</h2>

<p>factorialについては線形再帰も繰り返しもScheme論文でやったので軽めに</p>

<p>Scheme論文からSICPの初版まででも10年くらい経ってたと思いますが<br>
ずっとこのへんにこだわりつづけてるようですね</p>

<p>置換モデルで再帰型のfactorialを評価すると山型になります<br>
繰り返し型のfactorialを評価すると同じ形が繰り返し出てきます</p>

<ul>
<li>再帰型のプロセスではインタプリタが後で行う操作を覚えておかなければならない</li>
<li>覚えておく情報量はnに比例して増加する</li>
<li>だから線形再帰プロセスと呼ぶ</li>
<li>繰り返し型のプロセスでは、productとcounterとmax-countだけ覚えておけばよい</li>
<li>繰り返しの回数はnに比例して増加する</li>
<li><p>だから線形繰り返しプロセスと呼ぶ</p></li>
<li><p>繰り返し型のプロセスでは、定まった数の変数で完全にプロセスの状態を記述できる</p></li>
<li><p>もし、プロセスの途中で止めてしまったとしても、それらの変数さえわかっていれば続きから実行できる</p></li>
<li><p>再帰型のプロセスでは変数にあらわれない状態をインタプリタが管理している</p></li>
</ul>

<p>繰り返し型のプロセスと継続と関係づけようとしているのかな？<br>
そうでもないかな？</p>

<ul>
<li>再帰型のプロセスと、再帰型の手続きを混同するなよ！</li>
<li>繰り返し型プロセスのfactorialも、コード上では再帰している</li>
</ul>

<p>「再帰型プロセス」っていう概念に別の言葉を割り当てることはできなかったものか</p>

<h3 id="toc_3">Exercise 1.9.</h3>

<div><pre><code class="language-none">(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))</code></pre></div>

<p>で(+ 4 5)を評価する</p>

<div><pre><code class="language-none">  (+ 4 5)
= (inc (+ (dec 4) 5))
= (inc (+ 3 5))
= (inc (inc (+ (dec 3) 5)))
= (inc (inc (+ 2 5)))
= (inc (inc (inc (+ (dec 2) 5))))
= (inc (inc (inc (+ 1 5))))
= (inc (inc (inc (inc (+ (dec 1) 5)))))
= (inc (inc (inc (inc (+ 0 5)))))
= (inc (inc (inc (inc 5))))
= (inc (inc (inc 6)))
= (inc (inc 7))
= (inc 8)
= 9</code></pre></div>

<p>線形再帰プロセスでした</p>

<div><pre><code class="language-none">(define (o+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))</code></pre></div>

<p>で(+ 4 5)を評価する</p>

<div><pre><code class="language-none">  (+ 4 5)
= (+ (dec 4) (inc 5))
= (+ 3 6)
= (+ (dec 3) (inc 6))
= (+ 2 7)
= (+ (dec 2) (inc 7))
= (+ 1 8)
= (+ (dec 1) (inc 8))
= (+ 0 9)
= 9</code></pre></div>

<p>線形繰り返しプロセスでした</p>

<h3 id="toc_4">Exercise 1.10.</h3>

<p>ありがとうAckermann（何かのマネ</p>

<p><code>(A 1 10)</code>を置換モデルで評価すると（やりません</p>

<p><code>(f n)</code> = <code>(A 0 n)</code> = 2n<br>
これはすぐわかる</p>

<p><code>(g n)</code>はどうかな<br>
<code>(g 1)</code> = <code>(A 1 1)</code> = 2 はすぐわかる<br>
n &gt; 2 のときは（雑に）</p>

<div><pre><code class="language-none">  (g n)
= (A 1 n)
= (A 0 (A 1 (n - 1)))
= (f (g (n - 1)))
= (f (f (g (n - 2))))
= (f (f (... (g(1)))))
= 2・2・2・...・2
= 2^n</code></pre></div>

<p><code>(h 1)</code> = <code>(A 2 1)</code> = 2<br>
n &gt; 2 のときは（雑に）</p>

<div><pre><code class="language-none">  (h n)
= (A 2 n)
= (A 1 (A 2 (n - 1)))
= (g (h (n - 1)))
= (g (g (... (h(1)))))
= 2^2^...^2</code></pre></div>

<p>^って右から結合だったっけ</p>

<p>ところでこれプログラミングの勉強？やっぱり置換モデルで・・・<br>
と思って見返すと、上の解き方がだいたい置換モデルと言えなくもない</p>

<h2 id="toc_5">1.2.2 Tree Recursion</h2>

<ul>
<li>もう一つのよくあるパターンは樹状再帰</li>
</ul>

<p>置換モデルで式を並べるのは諦めた（？）ようで、樹形図になってますが<br>
ここは負けじと置換モデルで書いてみます</p>

<div><pre><code class="language-none">  (fib 5                                                                                    )
= (+ (fib 4                                                ) (fib 3                        ))
= (+ (+ (fib 3                        ) (fib 2            )) (+ (fib 2            ) (fib 1)))
= (+ (+ (+ (fib 2            ) (fib 1)) (+ (fib 1) (fib 0))) (+ (+ (fib 1) (fib 0)) (fib 1)))
= (+ (+ (+ (+ (fib 1) (fib 0)) (fib 1)) (+ (fib 1) (fib 0))) (+ (+ (fib 1) (fib 0)) (fib 1)))
= (+ (+ (+ (+ 1       0      ) 1      ) (+ 1       0      )) (+ (+ 1       0      ) 1      ))
= 5</code></pre></div>

<p>すくなくとも繰り返しプロセスでないことはまちがいない</p>

<p>樹形図が1次元になるのがS式の偉大なところ？<br>
さらにインデントをつけると樹形図っぽくなるかな？</p>

<div><pre><code class="language-none">= (+ 
     (+ 
        (+ 
           (+ 
              (fib 1)
              (fib 0))
           (fib 1))
        (+ 
           (fib 1)
           (fib 0)))
     (+
        (+
           (fib 1)
           (fib 0))
        (fib 1)))</code></pre></div>

<p>・・・そうでもないか</p>

<ul>
<li>これはフィボナッチ数を計算するにはひどい方法だ</li>
<li>(fib 3)を2回計算してたりして計算のステップが指数的に増える</li>
<li>樹状再帰では計算ステップの数はノードの数に比例し、必要なスペースは木の深さに比例する</li>
</ul>

<p>深さが増えると計算ステップは指数的に増えるってわけだな</p>

<ul>
<li>繰り返しでも計算できて、線形繰り返しになる</li>
<li>樹状再帰は階層構造を持つデータを操作するのに適している</li>
</ul>

<h3 id="toc_6">Example: Counting change</h3>

<ul>
<li>ある金額を、50セント、25セント、10セント、5セント、1セント硬貨に両替する方法は何通り？</li>
<li>これは、再帰手続きであれば簡単に書ける</li>
</ul>

<p>慣れないと簡単でもないと思いますです</p>

<ul>
<li>aセントをn種の硬貨を使って両替する方法の数は</li>
<li>aセントを、dセント硬貨を除いた残りの種類の硬貨で両替する方法の数と</li>
<li>(a - d)セントをすべての種類の硬貨で両替する方法の数の和</li>
</ul>

<p>ここが飲み込めるかどうかですかね<br>
問題をふたつの小問題に分けています<br>
ひとつは硬貨の種類が減った問題<br>
もうひとつは金額が減った問題<br>
このふたつを合わせるともとの問題をもれなくカバーしている・・・はずなんですよね</p>

<p>注では10セントを1セントと5セントで払う場合を考えてみろと書いてありますが<br>
6セントのほうがいいんじゃないかなー<br>
11セントじゃないとダメかなー<br>
6セントでやってみますよ</p>

<p>a) 6セントを2種類の硬貨(1セントと5セント)で両替する</p>

<p>がスタートです<br>
a=6、n=2ですね</p>

<p>これはふたつの問題に別れます<br>
上の条件を馬鹿正直に適用していきます<br>
まずはd=1とします</p>

<p>b) 6セントを1種類の硬貨(5セント)で両替する<br>
c) 6-1=5セントを2種類の硬貨(1セントと5セント)で両替する</p>

<p>b)をさらにふたつの問題に分けます<br>
こんどはd=5になります<br>
自明と思われても書いていきますよ</p>

<p>d) 6セントを0種類の硬貨で両替する<br>
e) 6-5=1セントを1種類の硬貨(=5セント)を使って両替する</p>

<p>d)は0通りと考えないと答えが合いません<br>
つまりn=0のとき答えは0とします</p>

<p>e)はさらにふたつの問題に別れます</p>

<p>f) 1セントを0種類の硬貨を使って両替する<br>
g) 1-5=-4セントを1種類の硬貨(=5セント)を使って両替する</p>

<p>f)はn=0ですから0とおり<br>
g)は0通りと考えないと答えが合いません<br>
つまりa&lt;0のとき答えは0とします</p>

<p>これでb)の両替方法は0とおりということがわかりました<br>
すばらしい</p>

<p>c)をふたつの問題に分けます<br>
さっきと合わせてd=1とします</p>

<p>h) 5セントを1種類の硬貨(5セント)で両替する<br>
i) 5-1=4セントを2種類の硬貨(1セントと5セント)で両替する</p>

<p>h)を分けます</p>

<p>j) 5セントを0種類の硬貨を使って両替する<br>
k) 5-5=0セントを1種類の硬貨(=5セント)を使って両替する</p>

<p>j)は0とおり<br>
k)は1とおりになってほしいですね<br>
a=0のとき答えは1とします</p>

<p>パターンが見えてきました<br>
あとg)が残っていますがaが4→3→2→1→0となって1とおりですね</p>

<p>ということで全部で3とおり<br>
わかった気がします</p>

<p>上に挙げた問題の分割方法と、○○のとき答えは○をそのままコードにすると<br>
ちゃんと答えが出てきます<br>
わかってはいるんだけどあら不思議、って感覚</p>

<p>まだ(1 5 10 25 50)みたいなリストの使い方は出てきてませんので<br>
コインの額面はcondでごりっと書いてあります</p>

<h3 id="toc_7">Exercise 1.11.</h3>

<p>フィボナッチをそのまま拡張するだけなので難しくはない<br>
関数の名前が被らないようにしないと・・・</p>

<p>再帰型</p>

<div><pre><code class="language-none">(define (f-1-11-r n)
  (cond ((&lt; n 3) n)
        (else (+ (f-1-11-r (- n 1))
                 (f-1-11-r (- n 2))
                 (f-1-11-r (- n 3))))))</code></pre></div>

<p>繰り返し型</p>

<div><pre><code class="language-none">(define (f-1-11-i n)
  (define (iter a b c count)
    (cond ((= count 0) c)
          (else (iter (+ a b c) a b (- count 1)))))
  (iter 2 1 0 n))</code></pre></div>

<p>なんか常にもったいない計算をしている気がしますがこれでいいんでしょう<br>
オーダには関係ないしね！</p>

<h3 id="toc_8">Exercise 1.12.</h3>

<p>パスカルの三角形の「要素」を求めろっていってるから、三角形は書かなくていいんだよね？<br>
上からn番目、左からk番目の要素を求めるよ！</p>

<p>三角形をじっと見ながら問題に書いてあることをそのまま式にします</p>

<p>三角形の辺の数は1<br>
→ k=1かk=nなら1<br>
三角形の内側の数は、上のふたつの数の和<br>
→ 上から(n-1)番目、左から(k - 1)番目の数と上から(n-1)番目、左からk番目の数の和</p>

<p>さらにこれをそのままコードにします</p>

<div><pre><code class="language-none">(define (pascal n k)
  (cond ((or (= k 1) (= k n)) 1)
        (else (+ (pascal (- n 1) (- k 1))
                 (pascal (- n 1) k)))))</code></pre></div>

<p>両替の例もそうでしたけどこういうものです、っていうのを書くだけで<br>
答えが出てしまうのはちょっと不思議な感覚です</p>

<h3 id="toc_9">Excercise 1.13.</h3>

<p>どうみても数学の問題だけれどもここに書いてあるのは何か意味があるのかな<br>
フィボナッチ数がこんなルートだらけの式で表せるというのにはびっくりしたものだけど</p>

<p>まずFib(n)=(φ^n-ψ^n)/√5を証明しろと書いてあるのでやってみます</p>

<p>φ=(1+√5)/2 ;1.62くらい<br>
ψ=(1-√5)/2 ;-0.62くらい</p>

<p>Fib(1)=1<br>
(φ^1-ψ^1)/√5=√5/√5=1<br>
よってn=1のときは成り立つ</p>

<p>Fib(2)=1<br>
(φ^2-ψ^2)/√5=(φ+ψ)(φ-ψ)/√5=(1*√5)/√5=1<br>
よってn=2のときも成り立つ</p>

<p>n=k-2、n=k-1のとき成り立つとする<br>
  Fib(k-1)+Fib(k-2)<br>
= (φ^(k-1)-ψ^(k-1))/√5 + (φ^(k-2)-ψ^(k-2))/√5<br>
= (φ^(k-2)(φ+1)-ψ^(k-2)(ψ+1))/√5</p>

<p>ということはφ+1=φ^2、ψ+1=ψ^2になればいいわけだな<br>
そううまくいくのか？<br>
てよく見たらφ^2=φ+1て書いてあるじゃないか<br>
いちおう計算しとく</p>

<p>φ^2<br>
= ((1+√5)/2)^2<br>
= (1+2√5+5)/4<br>
= (6+2√5)/4<br>
= (1+√5)/2+1</p>

<p>ほんとだ<br>
ほとんど同じだけど</p>

<p>ψ^2<br>
= ((1-√5)/2)^2<br>
= (1-2√5+5)/4<br>
= (6-2√5)/4<br>
= (1-√5)/2+1</p>

<p>というわけで元の式は</p>

<p>= (φ^(k-2)(φ+1)-ψ^(k-2)(ψ+1))/√5<br>
= (φ^k-ψ^k)/√5<br>
= Fib(k)</p>

<p>よってn=kの時も成り立つ<br>
ゆえにnが任意の自然数のとき成り立つ、と<br>
でもやっぱり不思議だなあ</p>

<p>であとなにするんだっけ<br>
Fib(n)がφ^n/√5にもっとも近い整数である、か</p>

<p>Fib(n)=φ^n/√5-ψ^n/√5<br>
ψがだいたい-0.6で√5≒2.23だからまあきっとそうなんだろうね<br>
キチンと書くとどうなるのかな<br>
|ψ^n/√5|が1/2より小さいって言えばいいのか</p>

<p>n=1のときを考える<br>
両方2乗して引き算<br>
  (1/2)^2-(ψ/√5)^2<br>
= 1/4-((1-√5)/2)^2/5<br>
= 1/4-(6-2√5)/20<br>
= (-1+2√5)/20</p>

<blockquote>
<p>0</p>
</blockquote>

<p>うんOK</p>




</body>

</html>
