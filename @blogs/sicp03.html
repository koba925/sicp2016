<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<title>sicp03</title>



</head>

<body>

<h1 id="toc_0">SICPを読む(3)</h1>

<h2 id="toc_1">1.2 Procedures and the Processes They Generate</h2>

<ul>
<li>基本的なプログラムの構成要素について学んできたがそれだけでは充分ではない</li>
<li>さまざまなタイプの手続きによって生成されるプロセスを予測する能力が必要</li>
</ul>

<p>何度も強調されてます<br>
自分はちょっと書いてみてすぐ動かしてああうまくいった（あるいはうまくいかない）、的に<br>
やることが多いので刺さります<br>
いやだって頭のなかで考えるのが苦手で・・・<br>
つまり素質が<br>
いやいや</p>

<ul>
<li>手続きは、直前の段階に基づいて次の段階をどのように作り出すかを指定する</li>
<li>そして、段階の積み重ねが全体としてどのようなふるまいになるのかを知りたい</li>
</ul>

<p>深いことが書いてあるようなそうでもないような<br>
いつか真の意味がわかる、みたいなときが来るんでしょうか</p>

<h2 id="toc_2">1.2.1 Linear Recursion and Iteration</h2>

<p>factorialについては線形再帰も繰り返しもScheme論文でやったので軽めに</p>

<p>Scheme論文からSICPの初版まででも10年くらい経ってたと思いますが<br>
ずっとこのへんにこだわりつづけてるようですね</p>

<p>置換モデルで再帰型のfactorialを評価すると山型になります<br>
繰り返し型のfactorialを評価すると同じ形が繰り返し出てきます</p>

<ul>
<li>再帰型のプロセスではインタプリタが後で行う操作を覚えておかなければならない</li>
<li>覚えておく情報量はnに比例して増加する</li>
<li>だから線形再帰プロセスと呼ぶ</li>
<li>繰り返し型のプロセスでは、productとcounterとmax-countだけ覚えておけばよい</li>
<li>繰り返しの回数はnに比例して増加する</li>
<li><p>だから線形繰り返しプロセスと呼ぶ</p></li>
<li><p>繰り返し型のプロセスでは、定まった数の変数で完全にプロセスの状態を記述できる</p></li>
<li><p>もし、プロセスの途中で止めてしまったとしても、それらの変数さえわかっていれば続きから実行できる</p></li>
<li><p>再帰型のプロセスでは変数にあらわれない状態をインタプリタが管理している</p></li>
</ul>

<p>繰り返し型のプロセスと継続と関係づけようとしているのかな？<br>
そうでもないかな？</p>

<ul>
<li>再帰型のプロセスと、再帰型の手続きを混同するなよ！</li>
<li>繰り返し型プロセスのfactorialも、コード上では再帰している</li>
</ul>

<p>「再帰型プロセス」っていう概念に別の言葉を割り当てることはできなかったものか</p>

<h3 id="toc_3">Exercise 1.9.</h3>

<div><pre><code class="language-none">(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))</code></pre></div>

<p>で(+ 4 5)を評価する</p>

<div><pre><code class="language-none">  (+ 4 5)
= (inc (+ (dec 4) 5))
= (inc (+ 3 5))
= (inc (inc (+ (dec 3) 5)))
= (inc (inc (+ 2 5)))
= (inc (inc (inc (+ (dec 2) 5))))
= (inc (inc (inc (+ 1 5))))
= (inc (inc (inc (inc (+ (dec 1) 5)))))
= (inc (inc (inc (inc (+ 0 5)))))
= (inc (inc (inc (inc 5))))
= (inc (inc (inc 6)))
= (inc (inc 7))
= (inc 8)
= 9</code></pre></div>

<p>線形再帰プロセスでした</p>

<div><pre><code class="language-none">(define (o+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))</code></pre></div>

<p>で(+ 4 5)を評価する</p>

<div><pre><code class="language-none">  (+ 4 5)
= (+ (dec 4) (inc 5))
= (+ 3 6)
= (+ (dec 3) (inc 6))
= (+ 2 7)
= (+ (dec 2) (inc 7))
= (+ 1 8)
= (+ (dec 1) (inc 8))
= (+ 0 9)
= 9</code></pre></div>

<p>線形繰り返しプロセスでした</p>

<h3 id="toc_4">Exercise 1.10.</h3>

<p>ありがとうAckermann（何かのマネ</p>

<p><code>(A 1 10)</code>を置換モデルで評価すると（やりません</p>

<p><code>(f n)</code> = <code>(A 0 n)</code> = 2n<br>
これはすぐわかる</p>

<p><code>(g n)</code>はどうかな<br>
<code>(g 1)</code> = <code>(A 1 1)</code> = 2 はすぐわかる<br>
n &gt; 2 のときは（雑に）</p>

<div><pre><code class="language-none">  (g n)
= (A 1 n)
= (A 0 (A 1 (n - 1)))
= (f (g (n - 1)))
= (f (f (g (n - 2))))
= (f (f (... (g(1)))))
= 2・2・2・...・2
= 2^n</code></pre></div>

<p><code>(h 1)</code> = <code>(A 2 1)</code> = 2<br>
n &gt; 2 のときは（雑に）</p>

<div><pre><code class="language-none">  (h n)
= (A 2 n)
= (A 1 (A 2 (n - 1)))
= (g (h (n - 1)))
= (g (g (... (h(1)))))
= 2^2^...^2</code></pre></div>

<p>^って右から結合だったっけ</p>

<p>ところでこれプログラミングの勉強？やっぱり置換モデルで・・・<br>
と思って見返すと、上の解き方がだいたい置換モデルと言えなくもない</p>

<h2 id="toc_5">1.2.2 Tree Recursion</h2>

<ul>
<li>もう一つのよくあるパターンは樹状再帰</li>
</ul>

<p>置換モデルで式を並べるのは諦めた（？）ようで、樹形図になってますが<br>
ここは負けじと置換モデルで書いてみます</p>

<div><pre><code class="language-none">  (fib 5                                                                                    )
= (+ (fib 4                                                ) (fib 3                        ))
= (+ (+ (fib 3                        ) (fib 2            )) (+ (fib 2            ) (fib 1)))
= (+ (+ (+ (fib 2            ) (fib 1)) (+ (fib 1) (fib 0))) (+ (+ (fib 1) (fib 0)) (fib 1)))
= (+ (+ (+ (+ (fib 1) (fib 0)) (fib 1)) (+ (fib 1) (fib 0))) (+ (+ (fib 1) (fib 0)) (fib 1)))
= (+ (+ (+ (+ 1       0      ) 1      ) (+ 1       0      )) (+ (+ 1       0      ) 1      ))
= 5</code></pre></div>

<p>すくなくとも繰り返しプロセスでないことはまちがいない</p>

<p>樹形図が1次元になるのがS式の偉大なところ？<br>
さらにインデントをつけると樹形図っぽくなるかな？</p>

<div><pre><code class="language-none">= (+ 
     (+ 
        (+ 
           (+ 
              (fib 1)
              (fib 0))
           (fib 1))
        (+ 
           (fib 1)
           (fib 0)))
     (+
        (+
           (fib 1)
           (fib 0))
        (fib 1)))</code></pre></div>

<p>・・・そうでもないか</p>

<ul>
<li>これはフィボナッチ数を計算するにはひどい方法だ</li>
<li>(fib 3)を2回計算してたりして計算のステップが指数的に増える</li>
<li>樹状再帰では計算ステップの数はノードの数に比例し、必要なスペースは木の深さに比例する</li>
</ul>

<p>深さが増えると計算ステップは指数的に増えるってわけだな</p>

<ul>
<li>繰り返しでも計算できて、線形繰り返しになる</li>
<li>樹状再帰は階層構造を持つデータを操作するのに適している</li>
</ul>

<h3 id="toc_6">Example: Counting change</h3>

<ul>
<li>ある金額を、50セント、25セント、10セント、5セント、1セント硬貨に両替する方法は何通り？</li>
<li>これは、再帰手続きであれば簡単に書ける</li>
</ul>

<p>慣れないと簡単でもないと思う</p>

<ul>
<li>aセントをn種の硬貨を使って両替する方法の数は</li>
<li>aセントを、dセント硬貨を除いた残りの種類の硬貨で両替する方法の数と</li>
<li>(a - d)セントをすべての種類の硬貨で両替する方法の数の和</li>
</ul>

<p>まずはここが飲み込めるかどうか<br>
問題をふたつの小問題に分けている<br>
ひとつは硬貨の種類が減った問題<br>
もうひとつは金額が減った問題<br>
このふたつを合わせるともとの問題をもれなくカバーしている</p>

<p>これをコードに落とすのも</p>




</body>

</html>
