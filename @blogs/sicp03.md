# SICPを読む(3)

## 1.2 Procedures and the Processes They Generate

* 基本的なプログラムの構成要素について学んできたがそれだけでは充分ではない
* さまざまなタイプの手続きによって生成されるプロセスを予測する能力が必要

何度も強調されてます
自分はちょっと書いてみてすぐ動かしてああうまくいった（あるいはうまくいかない）、的に
やることが多いので刺さります
いやだって頭のなかで考えるのが苦手で・・・
つまり素質が
いやいや

* 手続きは、直前の段階に基づいて次の段階をどのように作り出すかを指定する
* そして、段階の積み重ねが全体としてどのようなふるまいになるのかを知りたい

深いことが書いてあるようなそうでもないような
いつか真の意味がわかる、みたいなときが来るんでしょうか

## 1.2.1 Linear Recursion and Iteration

factorialについては線形再帰も繰り返しもScheme論文でやったので軽めに

Scheme論文からSICPの初版まででも10年くらい経ってたと思いますが
ずっとこのへんにこだわりつづけてるようですね

置換モデルで再帰型のfactorialを評価すると山型になります
繰り返し型のfactorialを評価すると同じ形が繰り返し出てきます

* 再帰型のプロセスではインタプリタが後で行う操作を覚えておかなければならない
* 覚えておく情報量はnに比例して増加する
* だから線形再帰プロセスと呼ぶ
* 繰り返し型のプロセスでは、productとcounterとmax-countだけ覚えておけばよい
* 繰り返しの回数はnに比例して増加する
* だから線形繰り返しプロセスと呼ぶ

* 繰り返し型のプロセスでは、定まった数の変数で完全にプロセスの状態を記述できる
* もし、プロセスの途中で止めてしまったとしても、それらの変数さえわかっていれば続きから実行できる
* 再帰型のプロセスでは変数にあらわれない状態をインタプリタが管理している

繰り返し型のプロセスと継続と関係づけようとしているのかな？
そうでもないかな？

* 再帰型のプロセスと、再帰型の手続きを混同するなよ！
* 繰り返し型プロセスのfactorialも、コード上では再帰している

「再帰型プロセス」っていう概念に別の言葉を割り当てることはできなかったものか

### Exercise 1.9.

```
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))
```

で(+ 4 5)を評価する

```
  (+ 4 5)
= (inc (+ (dec 4) 5))
= (inc (+ 3 5))
= (inc (inc (+ (dec 3) 5)))
= (inc (inc (+ 2 5)))
= (inc (inc (inc (+ (dec 2) 5))))
= (inc (inc (inc (+ 1 5))))
= (inc (inc (inc (inc (+ (dec 1) 5)))))
= (inc (inc (inc (inc (+ 0 5)))))
= (inc (inc (inc (inc 5))))
= (inc (inc (inc 6)))
= (inc (inc 7))
= (inc 8)
= 9
```

線形再帰プロセスでした

```
(define (o+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
```

で(+ 4 5)を評価する

```
  (+ 4 5)
= (+ (dec 4) (inc 5))
= (+ 3 6)
= (+ (dec 3) (inc 6))
= (+ 2 7)
= (+ (dec 2) (inc 7))
= (+ 1 8)
= (+ (dec 1) (inc 8))
= (+ 0 9)
= 9
```

線形繰り返しプロセスでした

### Exercise 1.10.

ありがとうAckermann（何かのマネ

`(A 1 10)`を置換モデルで評価すると（やりません

`(f n)` = `(A 0 n)` = 2n
これはすぐわかる

`(g n)`はどうかな
`(g 1)` = `(A 1 1)` = 2 はすぐわかる
n > 2 のときは（雑に）

```
  (g n)
= (A 1 n)
= (A 0 (A 1 (n - 1)))
= (f (g (n - 1)))
= (f (f (g (n - 2))))
= (f (f (... (g(1)))))
= 2・2・2・...・2
= 2^n
```

`(h 1)` = `(A 2 1)` = 2
n > 2 のときは（雑に）

```
  (h n)
= (A 2 n)
= (A 1 (A 2 (n - 1)))
= (g (h (n - 1)))
= (g (g (... (h(1)))))
= 2^2^...^2
```

^って右から結合だったっけ

ところでこれプログラミングの勉強？やっぱり置換モデルで・・・
と思って見返すと、上の解き方がだいたい置換モデルと言えなくもない

## 1.2.2 Tree Recursion

* もう一つのよくあるパターンは樹状再帰

置換モデルで式を並べるのは諦めた（？）ようで、樹形図になってますが
ここは負けじと置換モデルで書いてみます

```
  (fib 5                                                                                    )
= (+ (fib 4                                                ) (fib 3                        ))
= (+ (+ (fib 3                        ) (fib 2            )) (+ (fib 2            ) (fib 1)))
= (+ (+ (+ (fib 2            ) (fib 1)) (+ (fib 1) (fib 0))) (+ (+ (fib 1) (fib 0)) (fib 1)))
= (+ (+ (+ (+ (fib 1) (fib 0)) (fib 1)) (+ (fib 1) (fib 0))) (+ (+ (fib 1) (fib 0)) (fib 1)))
= (+ (+ (+ (+ 1       0      ) 1      ) (+ 1       0      )) (+ (+ 1       0      ) 1      ))
= 5
```

すくなくとも繰り返しプロセスでないことはまちがいない

樹形図が1次元になるのがS式の偉大なところ？
さらにインデントをつけると樹形図っぽくなるかな？

```
= (+ 
     (+ 
        (+ 
           (+ 
              (fib 1)
              (fib 0))
           (fib 1))
        (+ 
           (fib 1)
           (fib 0)))
     (+
        (+
           (fib 1)
           (fib 0))
        (fib 1)))
```

・・・そうでもないか

* これはフィボナッチ数を計算するにはひどい方法だ
* (fib 3)を2回計算してたりして計算のステップが指数的に増える
* 樹状再帰では計算ステップの数はノードの数に比例し、必要なスペースは木の深さに比例する

深さが増えると計算ステップは指数的に増えるってわけだな

* 繰り返しでも計算できて、線形繰り返しになる
* 樹状再帰は階層構造を持つデータを操作するのに適している

### Example: Counting change

* ある金額を、50セント、25セント、10セント、5セント、1セント硬貨に両替する方法は何通り？
* これは、再帰手続きであれば簡単に書ける

慣れないと簡単でもないと思いますです

* aセントをn種の硬貨を使って両替する方法の数は
* aセントを、dセント硬貨を除いた残りの種類の硬貨で両替する方法の数と
* (a - d)セントをすべての種類の硬貨で両替する方法の数の和

ここが飲み込めるかどうかですかね
問題をふたつの小問題に分けています
ひとつは硬貨の種類が減った問題
もうひとつは金額が減った問題
このふたつを合わせるともとの問題をもれなくカバーしている・・・はずなんですよね

注では10セントを1セントと5セントで払う場合を考えてみろと書いてありますが
6セントのほうがいいんじゃないかなー
11セントじゃないとダメかなー
6セントでやってみますよ

a) 6セントを2種類の硬貨(1セントと5セント)で両替する

がスタートです
a=6、n=2ですね

これはふたつの問題に別れます
上の条件を馬鹿正直に適用していきます
まずはd=1とします

b) 6セントを1種類の硬貨(5セント)で両替する
c) 6-1=5セントを2種類の硬貨(1セントと5セント)で両替する

b)をさらにふたつの問題に分けます
こんどはd=5になります
自明と思われても書いていきますよ

d) 6セントを0種類の硬貨で両替する
e) 6-5=1セントを1種類の硬貨(=5セント)を使って両替する

d)は0通りと考えないと答えが合いません
つまりn=0のとき答えは0とします

e)はさらにふたつの問題に別れます

f) 1セントを0種類の硬貨を使って両替する
g) 1-5=-4セントを1種類の硬貨(=5セント)を使って両替する

f)はn=0ですから0とおり
g)は0通りと考えないと答えが合いません
つまりa<0のとき答えは0とします

これでb)の両替方法は0とおりということがわかりました
すばらしい

c)をふたつの問題に分けます
さっきと合わせてd=1とします

h) 5セントを1種類の硬貨(5セント)で両替する
i) 5-1=4セントを2種類の硬貨(1セントと5セント)で両替する

h)を分けます

j) 5セントを0種類の硬貨を使って両替する
k) 5-5=0セントを1種類の硬貨(=5セント)を使って両替する

j)は0とおり
k)は1とおりになってほしいですね
a=0のとき答えは1とします

パターンが見えてきました
あとg)が残っていますがaが4→3→2→1→0となって1とおりですね

ということで全部で3とおり
わかった気がします

上に挙げた問題の分割方法と、○○のとき答えは○をそのままコードにすると
ちゃんと答えが出てきます
わかってはいるんだけどあら不思議、って感覚

まだ(1 5 10 25 50)みたいなリストの使い方は出てきてませんので
コインの額面はcondでごりっと書いてあります

