# SICPを読む(3)

## 1.2 Procedures and the Processes They Generate

* 基本的なプログラムの構成要素について学んできたがそれだけでは充分ではない
* さまざまなタイプの手続きによって生成されるプロセスを予測する能力が必要

何度も強調されてます
自分はちょっと書いてみてすぐ動かしてああうまくいった（あるいはうまくいかない）、的に
やることが多いので刺さります
いやだって頭のなかで考えるのが苦手で・・・
つまり素質が
いやいや

* 手続きは、直前の段階に基づいて次の段階をどのように作り出すかを指定する
* そして、段階の積み重ねが全体としてどのようなふるまいになるのかを知りたい

深いことが書いてあるようなそうでもないような
いつか真の意味がわかる、みたいなときが来るんでしょうか

## 1.2.1 Linear Recursion and Iteration

factorialについては線形再帰も繰り返しもScheme論文でやったので軽めに

Scheme論文からSICPの初版まででも10年くらい経ってたと思いますが
ずっとこのへんにこだわりつづけてるようですね

置換モデルで再帰型のfactorialを評価すると山型になります
繰り返し型のfactorialを評価すると同じ形が繰り返し出てきます

* 再帰型のプロセスではインタプリタが後で行う操作を覚えておかなければならない
* 覚えておく情報量はnに比例して増加する
* だから線形再帰プロセスと呼ぶ
* 繰り返し型のプロセスでは、productとcounterとmax-countだけ覚えておけばよい
* 繰り返しの回数はnに比例して増加する
* だから線形繰り返しプロセスと呼ぶ

* 繰り返し型のプロセスでは、定まった数の変数で完全にプロセスの状態を記述できる
* もし、プロセスの途中で止めてしまったとしても、それらの変数さえわかっていれば続きから実行できる
* 再帰型のプロセスでは変数にあらわれない状態をインタプリタが管理している

繰り返し型のプロセスと継続と関係づけようとしているのかな？
そうでもないかな？

* 再帰型のプロセスと、再帰型の手続きを混同するなよ！
* 繰り返し型プロセスのfactorialも、コード上では再帰している

「再帰型プロセス」っていう概念に別の言葉を割り当てることはできなかったものか

### Exercise 1.9.

```
(define (+ a b)
  (if (= a 0)
      b
      (inc (+ (dec a) b))))
```

で(+ 4 5)を評価する

```
  (+ 4 5)
= (inc (+ (dec 4) 5))
= (inc (+ 3 5))
= (inc (inc (+ (dec 3) 5)))
= (inc (inc (+ 2 5)))
= (inc (inc (inc (+ (dec 2) 5))))
= (inc (inc (inc (+ 1 5))))
= (inc (inc (inc (inc (+ (dec 1) 5)))))
= (inc (inc (inc (inc (+ 0 5)))))
= (inc (inc (inc (inc 5))))
= (inc (inc (inc 6)))
= (inc (inc 7))
= (inc 8)
= 9
```

線形再帰プロセスでした

```
(define (o+ a b)
  (if (= a 0)
      b
      (+ (dec a) (inc b))))
```

で(+ 4 5)を評価する

```
  (+ 4 5)
= (+ (dec 4) (inc 5))
= (+ 3 6)
= (+ (dec 3) (inc 6))
= (+ 2 7)
= (+ (dec 2) (inc 7))
= (+ 1 8)
= (+ (dec 1) (inc 8))
= (+ 0 9)
= 9
```

線形繰り返しプロセスでした

### Exercise 1.10.

ありがとうAckermann（何かのマネ

`(A 1 10)`を置換モデルで評価すると（やりません

`(f n)` = `(A 0 n)` = 2n
これはすぐわかる

`(g n)`はどうかな
`(g 1)` = `(A 1 1)` = 2 はすぐわかる
n > 2 のときは（雑に）

```
  (g n)
= (A 1 n)
= (A 0 (A 1 (n - 1)))
= (f (g (n - 1)))
= (f (f (g (n - 2))))
= (f (f (... (g(1)))))
= 2・2・2・...・2
= 2^n
```

`(h 1)` = `(A 2 1)` = 2
n > 2 のときは（雑に）

```
  (h n)
= (A 2 n)
= (A 1 (A 2 (n - 1)))
= (g (h (n - 1)))
= (g (g (... (h(1)))))
= 2^2^...^2
```

^って右から結合だったっけ

ところでこれプログラミングの勉強？やっぱり置換モデルで・・・
と思って見返すと、上の解き方がだいたい置換モデルと言えなくもない

## 1.2.2 Tree Recursion

* もう一つのよくあるパターンは樹状再帰

置換モデルで式を並べるのは諦めた（？）ようで、樹形図になってますが
ここは負けじと置換モデルで書いてみます

```
  (fib 5                                                                                    )
= (+ (fib 4                                                ) (fib 3                        ))
= (+ (+ (fib 3                        ) (fib 2            )) (+ (fib 2            ) (fib 1)))
= (+ (+ (+ (fib 2            ) (fib 1)) (+ (fib 1) (fib 0))) (+ (+ (fib 1) (fib 0)) (fib 1)))
= (+ (+ (+ (+ (fib 1) (fib 0)) (fib 1)) (+ (fib 1) (fib 0))) (+ (+ (fib 1) (fib 0)) (fib 1)))
= (+ (+ (+ (+ 1       0      ) 1      ) (+ 1       0      )) (+ (+ 1       0      ) 1      ))
= 5
```

すくなくとも繰り返しプロセスでないことはまちがいない

樹形図が1次元になるのがS式の偉大なところ？
さらにインデントをつけると樹形図っぽくなるかな？

```
= (+ 
     (+ 
        (+ 
           (+ 
              (fib 1)
              (fib 0))
           (fib 1))
        (+ 
           (fib 1)
           (fib 0)))
     (+
        (+
           (fib 1)
           (fib 0))
        (fib 1)))
```

・・・そうでもないか

* これはフィボナッチ数を計算するにはひどい方法だ
* (fib 3)を2回計算してたりして計算のステップが指数的に増える




