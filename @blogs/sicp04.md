
# SICPを読む(4)

## 1.2.3 Orders of Growth

* プロセスがリソースを消費する度合いはプロセスによって大きく異なる
* 入力が大きくなるにつれ、リソースがどれくらいかを表すには「オーダ」記法を使うのが便利
* 問題のサイズをnで表し、そのときのリソースをR(n)で表す
* R(n)がf(n)と同じような感じで増えるときR(n)=Θ(f(n))と書く

さすがに大ざっぱすぎるかな
まあいいや
テキスト見てください

### Exercise 1.14.

さっき6セントでやったから雰囲気はわかります
オーダは指数オーダになりそうだけどもっと詳しくわかるのかな？
何かの累乗になる、以上は難しそうな気もしますけど
fibでは具体的にΘ(((1+√5)/2)^n)まで書いてあったし

やっぱり一応樹形図を描いてみます
それでわからなかったら置いとくことに

●樹形図

偏りの大きい2分木ができました

硬貨の種類は変わらないとして、n円を両替するときの深さは最大のところでn+5-1=n+4
必要なスペースは木の深さで決まるからΘ(n)
これは問題ないです

問題は計算ステップ数
2分木で深さがn+4だからいくら多くても2^(n+4)よりは少ないはず
+4がくっついてるけど8*2^nだから気にしなくてOK
だからといってΘ(2^n)かというとそうとも限らない気がします
よくでてくるO記法と違ってここで出てくるΘは上下から挟まれてます

> k1f(n) ≦ R(n) ≦ k2f(n)

完全に繁った2分木なら深さがnのときノードは2^(n+1)-1個あるはず
この樹形図は偏りが大きくてそれよりはかなり少ない
少ない度合いがnにかかわらず一定ならΘ(2^n)でいいんですが
そうでなければ2よりも小さい数のn乗に従うってことになります
基数が異なれば違うΘ
ぱっと見nが1増えたときに計算ステップ数が2倍になるとはちょっと思えません

実際どれくらいの勢いで増えるんでしょうか

```
(define step 0)

(define (count-change2 amount)
  (set! step 0)
  (cc2 amount 5)
  step)

(define (cc2 amount kinds-of-coins)
  (set! step (+ step 1))
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc2 amount
                      (- kinds-of-coins 1))
                 (cc2 (- amount
                         (first-denomination kinds-of-coins))
                      kinds-of-coins)))))

(check-eq? (count-change2 11) 55)

(define (list-cc n)
  (define (iter c)
    (display (count-change2 c)) (newline)
    (cond ((< c n) (iter (+ c 1)))))
  (iter 0))
```

どれどれ

```
> (list-cc 100)
1
11
13
15
:
:
3557
3777
3963
4149
:
:
13987
14491
14995
15499
```

やっぱりnが1増えるごとに2倍になるとは思えません
ということはFibみたいに一般項を求めるレベルでキッチリやらないとΘは決まらないのかなあ
ちょっと難しそうです
スルー
（数学の問題だし）

### Exercise 1.15

a.
`(p (sine (/ angle 3.0)))`を見るとpを呼ぶごとに角度が1/3になることがわかります
12.15*(1/3)^nが0.1以下になる最初のnは5だから5回

b.
1回再帰するごとに3倍大きな角度まで計算できるようになるので、計算ステップ数はlog3(a)
底が変わっても定数倍だからΘ(log(a))でいいかな
線形再帰だから必要なスペースも同じペースで成長してΘ(log(a))
## 1.2.4 Exponentiation

* べき乗を再帰で書くと、ステップ数もスペースもΘ(n)
* 繰り返しで書くとステップ数はΘ(n)、スペースはΘ(1)
* もっとうまいやり方がある

> ```
> (define (fast-expt b n)
>   (cond ((= n 0) 1)
>         ((even? n) (square (fast-expt b (/ n 2))))
>         (else (* b (fast-expt b (- n 1))))))
> ```

* これだと、1ステップ増えるごとに倍の大きさの数が処理できることになる
* ステップ数もスペースもΘ(log n)
* Θ(n)とΘ(log n)はnが大きくなるとびっくりするほど違う
* 再帰ではなく繰り返しでも書ける
* でも再帰で書くほどストレートには書けない

### Exercise 1.16.

で、繰り返しでも書いてみなさいと

* `(b^(n/2))^2 = (b^2)^(n/2)`を使え
* `b^n`を計算するとき、`a = 1`から始めて、`a*b^n`がいつも一定になるようにしなさい
* 「不変量」は繰り返しアルゴリズムを考えるときにとても役に立つ

不変量とか不変式とかときどき出てきてなんか役に立つものらしいんですが
ありがたみがよくわかってません

`a = 1`、`b^n = 5^7`というところから始めてみます
`a*b^n = 1*5^7`です
7は奇数なのでたぶん`(b^(n/2))^2 = (b^2)^(n/2)`は使わず
`a*b^n`を一定に保って`1*5^7 = 5*5^6`
つまり`a=5`、`b^n=5^6`となるのでしょう
これは問題なし

6は偶数なのできっとここで`5^6 = (5^3)^2 = (5^2)^3`を使います
どう使うといいんでしょうね
`5*5^6 = 5*(5^3)^2 = 5*(5^2)^3` と書いてみてもaがどう変わるのか見えてきません
・・・
あ、bは一定でaとnだけが変わっていくと思ってたけどbも変わっていいのかな？

そうか
こうか

```
(define (fast-expt-ex1-16 b n)
  (define (iter a b n)
    (cond ((= n 0) a)
          ((even? n) (iter a (* b b) (/ n 2)))
          (else (iter (* a b) b (- n 1)))))
  (iter 1 b n))
```

どれ

```
> (fast-expt-ex1-16 5 7)
78125
```

できた
変な思い込みで時間を使ってしまいました

不変量のありがたみはわかったようなわからないような

### Exercise 1.17.

* 同じようにして、かけ算をΘ(log n)の足し算で計算しなさい

えーと繰り返しプロセスで、とは書いてないね

```
(define (fast-* a b)
  (cond ((= b 0) 0)
        ((even? b) (double (fast-* a (halve b))))
        (else (+ a (fast-* a (- b 1))))))
```

### Exercise 1.18.

* じゃ今度は繰り返しプロセスでどうぞ

結局書くのか

```
(define (fast-iter-* a b)
  (define (iter c a b)
    (cond ((= b 0) c)
          ((even? b) (iter c (double a) (halve b)))
          (else (iter (+ c a) a (- b 1)))))
  (iter 0 a b))
```

こっちの方は当たり前に見える！
(double a) (halve b)のあたりが

### Exercise 1.19.

* おんなじ戦法でFibもΘ(log n)でやっちゃうよ!

FibがΘ(n)で計算できるくらいでは飽き足らないそうです
パターンは見えてきてます
半分にして2回やればいいんです（大ざっぱ

それをFibでどうやってやるかは問題に書いてくれてあります
コレはペンと紙でやったほうが速いな

以下
p'とか書きたいところだけどmarkdownしにくいのでp'をp#、p''をp##とか書きます

`a,b`にTを適用したものを`a#,b#`とし、
`a#,b#`にTを適用したものを`a##,b##`とします

つまり

```
a# = bq+aq+ap
b# = bp+aq
a## = b#q+a#q+a#p
b## = b#p+a#q
```

です
ここで

```
a## = b#q+a#q+a#p
    = (bp+aq)q+(bq+aq+ap)q+(bq+aq+ap)p
    = b(2pq+q^2)+a(2pq+q^2)+a(p^2+q^2)
```

ですから`a# = bq+aq+ap`の形と見比べて

```
p# = p^2+q^2
q# = 2pq+q^2
```

としてやるとTpqを2回適用するかわりにTp#q#を1回適用すればいいことになります
（b##の方の計算は省略しますが結果は同じ）

というわけでこう

```
(define (fib-ex1-19 n)
  (define (fib-iter a b p q count)
    (cond ((= count 0) b)
          ((even? count)
           (fib-iter a
                     b
                     (+ (* p p) (* q q))
                     (+ (* 2 p q) (* q q))
                     (/ count 2)))
          (else (fib-iter (+ (* b q) (* a q) (* a p))
                          (+ (* b p) (* a q))
                          p
                          q
                          (- count 1)))))
  (fib-iter 1 0 0 1 n))
```

しかしこのやりかたなんか頭よすぎますね
まったくstraightforwardではない
ちょっと思いつける感じがしません
何かきっと裏に理論があるんだろうな
