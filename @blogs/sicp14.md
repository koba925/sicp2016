# SICPを読む(14)

中途半端なところから再開

### Exercise 2.14.

* さまざまな計算でシステムのふるまいを調べて、上記の差異を説明せよ

本文中でもちょっとやりましたがその続き

* A/AとA/Bをやってみろ
* widthが小さいほうがわかりやすい
* center-percent形式で調べよ

とりあえず言われたとおりにやってみましょう

```
(define (center-percent i)
  (cons (center i) (percent i)))

(define R1 (make-center-percent 100 1))
(define R2 (make-center-percent 200 2))
```

からの

```
> (center-percent (div-interval R1 R1))
'(1.0002000200020003 . 1.9998000199980077)
> (center-percent (div-interval R1 R2))
'(0.5003001200480192 . 2.9994001199760016)
```

* centerはだいたい合ってるけど微妙に大きすぎる
* percentはほぼ被演算数のpercentの和になるけどそれよりは微妙に小さい

てとこでしょうか
A/AとA/Bを両方やれって言ってるのはなぜかな
単に１回だけだと信用できないから２回くらいはやってみろってことなのか
A/AとA/Bの間に何か違いがあるのか
あまり違いがある気がしませんが

それとこれがなぜ代数的に同じ式でも答えが異なることがある、の説明に
なるのかもよくわかりません

A/A、つまり1になるはずのものが(1 1)ではない、というのは

区間演算による任意の式EについてE'=E×A/Aとすると
代数的にはE=E'だけれども計算してみるとE≠E'である

ということにつながってる気はします
ただそれだとA/Bを計算させてる意味がないですね

もうちょっといろいろやってみるかな

```
> (center-percent (add-interval R1 R1))
'(200.0 . 1.0)
> (center-percent (add-interval R1 R2))
'(300.0 . 1.6666666666666667)
> (center-percent (add-interval R2 R2))
'(400.0 . 2.0)
> (center-percent (sub-interval R1 R2))
'(-100.0 . -5.0)
> (center-percent (sub-interval R2 R1))
'(100.0 . 5.0)
> (center-percent (mul-interval R1 R1))
'(10001.0 . 1.9998000199980004)
> (center-percent (mul-interval R1 R2))
'(20004.0 . 2.9994001199760048)
> (center-percent (mul-interval R2 R2))
'(40016.0 . 3.9984006397441028)
> (center-percent (div-interval R1 R1))
'(1.0002000200020003 . 1.9998000199980077)
> (center-percent (div-interval R1 R2))
'(0.5003001200480192 . 2.9994001199760016)
> (center-percent (div-interval R2 R1))
'(2.0006000600060005 . 2.999400119976016)
> (center-percent (div-interval R2 R2))
'(1.000800320128051 . 3.998400639744092)
```

足し算ではpercentが増えてないように見えてるところもありますけどこれはどうかな
A/BもやってみろというのはA+AだけじゃなくてA+Bもやっとけよ、ってことだったのかな
ちょっと遠回しすぎる気がしなくもないですが

足し算引き算の誤差をpercentで見るのは正しくないかもしれません
同じ数どうしで引き算すると0割りになってエラーになったりしますし
足し算でも引き算でも結果のwidthは非演算数のwidthの和
割合じゃなくて値そのもので見れば誤差は拡大しています

なお足し算引き算では答えのcenterは非演算数のcenterの和や差そのものになっています

かけ算は割り算と同じでやっぱりpercentは拡大して結果のcenterの積や商は
非演算数のcenterの積や商からずれます

こっちは割合で見るのが正しい気がします

まとめると

計算をすればするほどpercentやwidthが拡大する
かけ算割り算をするとさらにcenterもずれていく

くらいでよろしいでしょうか！
（あんまりよろしくない気もしている）

### Exercise 2.15.

* 不確定な数を表す変数が繰り返して現れない式の方が誤差が少ない、は正しいか？なぜ？

さっきの話からすると計算の回数が少ないほうが有利っぽいですね
不確定というのはつまり幅のあるということで(1 1)みたいなのはちょっと違うよ、と
いうことでしょう

さっきの式を例として考えてみます

R1R2/(R1+R2)だと不確定な数の計算は
R1R1、R1+R2、R1R2/(R1+R2)の3回

1/(1/R1)+(1/R2)だと不確定な数の計算は
1/R1、1/R2、1/(1/R1)+(1/R2)の3回

これは数え方がよくないぽいですね
1との計算では誤差が拡大することはないので
R1R2と1/R1では後者の方が誤差が小さくなります

演算に不確定な数が現れる数を数えましょう

R1R2/(R1+R2)だと
R1R2で2回、R1+R2で2回、R1R2/(R1+R2)で2回の計6回

1/(1/R1)+(1/R2)だと
1/R1で1回、1/R2で1回、(1/R1)+(1/R2)で2回、
1/(1/R1)+(1/R2)で1回の計5回

そういうことでいいんですかねえ

1との演算で誤差が拡大しないことを確認しておきます
足し算引き算はパーセントではなく幅で

```
> (define one (cons 1 1))
> (add-interval R1 one)
'(100.0 . 102.0)
> (add-interval one R1)
'(100.0 . 102.0)
> (sub-interval R1 one)
'(98.0 . 100.0)
> (sub-interval one R1)
'(-100.0 . -98.0)
> (center-percent (mul-interval R1 one))
'(100.0 . 1.0)
> (center-percent (mul-interval one R1))
'(100.0 . 1.0)
> (center-percent (div-interval R1 one))
'(100.0 . 1.0)
> (center-percent (div-interval one R1))
'(0.010001000100010001 . 1.0000000000000036)
```

OKですね

しかし「計算に不確定な数が現れる回数が少ない」ではなくて
「不確定な数を表す変数が繰り返して現れない」という表現になっている
ところがちょっと引っかかります

一度も登場しない変数は意味がないので
変数は１回だけ現れるか複数回現れるかのどちらかですね
そこから考えると同じことかな

同じ変数が繰り返し現れようが異なる変数がたくさん出てこようが
あんまり違う気がしないんで、なにかずれてる気もするんですけど

正しい、なぜなら計算に不確定な数が現れる回数が多くなるから

って答えればいいんでしょうか？

### Exercise 2.16.

* 代数的に同じ式が異なる答えを出すことがある理由を説明せよ

A/Aを掛け算すればすればどんな式でも、で説明になってるのかな・・・証明にはなってると思うけど

* こういう短所がない区間演算システムをつくることは可能か？不可能か？
* 警告：この問題はとても難しい

この警告は最初の問いにもかかってるのかな
かかってるとするとちょっと簡単な答えすぎるかもしれない

でも２番めの問いだけにかかってることにする
難しいのは直感でわかる
ついでに直感でいうと不可能な気がする

可能だとすると、この本でこれから説明される技を使うだろうからここで問題にはしないだろうし

なぜ不可能なのか
不可能ということは証明できるか

割り算さえなければたぶん可能だと思うんだよな
全部展開して同類項をまとめてから計算することにすれば
代数的に同じ式なら同じになるはず
全部展開した式が誤差のもっとも少ない式かというとそんなことはないと思うけど
答えがばらついたりはしないからこの問題の要件は満たすはず
その気になれば作れそう

割り算が入っても、なにか標準型みたいなものを考えて
その形にしてから計算することにできればいいんだけど・・・
作ってみ、と言われてもちょっと作れる気がしないなあ
作れないことを証明するのはこれまた大変そう

## 2.2 Hierarchical Data and the Closure Property

* ペアは複合データオブジェクトを作るための糊である
* ペアを図示するときには「箱矢印表記」を使う
* オブジェクトは箱を指す矢印で表される
* プリミティブなデータは箱に入る
* ペアはcarとcdrのふたつの箱で表される

箱じゃなくて矢印がオブジェクトなんだ
そう思って図を見ると見方が変わるかも？

* consは数だけではなくペアも組み合わせることができる
* ペアを使ってあらゆるデータ構造を表すことができる
* このように、ある操作で要素を組み合わせた結果をまた同じ操作で組み合わせられるとき、その操作は'closure property'を持つと言う
* closureによって階層構造を表すことができる
* 手続きの階層構造もclosureである

このclosureは手習いで出てきたclosureと同じものなんでしょうか
一見同じには見えませんが深いところでは同じものだったりするのかな

そもそも普通の英語としてのclosureがわかったほうがいいのかな
・・・
閉店とか閉鎖とか終了とか
あんまり参考になりませんでした

よく見たら注に書いてありました

* ここでのclosureということばは抽象代数から来ている
* ある集合について、その要素に演算を施した結果がまたその集合に属していれば、その集合はその演算について閉じている、と言う
* Lispコミュニティは（不幸にも）closureという言葉をまったく違った意味にも使っている
* そちらのclosureは手続きと自由変数を実装する手段を意味する

ですと
別物でした

* この本では後者の意味のclosureという言葉は用いない

了解しました

## 2.2.1 Representing Sequences

* ペアを使ってsequence(順序のついたデータの集まり)を作ることができる
* sequenceを扱うには、carに値を入れ、cdrが次のペアを指すようにしてつなげていく
* 最後の要素のcdrには、ペアでないものを入れて区別できるようにする

ここで、「ペアでないもの」として「nil」が登場します
あんまり具体的とは言えませんが
手習いでは頑なに`(quote ())`と書かれていたものです

* consで書くと`(cons 1 (cons 2 (cons 3 (cons 4 nil))))`という形

以後箱矢印の図は省略
このへん http://sicp.iijlab.net/fulltext/fig204.png

* これをリストと呼び、`(list 1 2 3 4)`とも書けるようになっている
* nilは要素のないリストとも読める

nilが何であるかについては議論がありすぎてめんどくさいので
後でquoteが導入されたら'()を使うことにしてnilを使うのはやめるそうです

## List operations

* リストを扱うには、順番にcdrしていくのが普通
* リストを最後までcdrしたかどうかを判断するためにはnull?が使える

このへんは手習いでもさんざんやりました
戒律になってましたね
この本では

* リストのlengthはそのリストのcdrのlengthに1を加えたものである
* 空リストのlengthは0である

をそのまま直訳したよ、みたいな書き方をしてて少し違う雰囲気を感じます
そのあと繰り返しスタイルでも書いてますけど

* cdrしながら、値となるリストをconsしていくやり方も使う

ふたつのリストをつなぐappendを例にあげています
appendは再帰プロセス「でも」書けるよ、と言って再帰プロセスのコードを載せておきながら
繰り返しプロセスのコードを載せてないのは不思議です
普通にやると逆順になるから？

### Exercise 2.17.

* リストの最後の要素のみを含むリストを返す手続きを定義せよ

空リストは渡されないと思ってていいんでしょうか
手習い流ではそうでしたが

```
(define (last-pair l)
  (if (null? (cdr l))
      l
      (last-pair (cdr l))))
```

もう少していねいにやるとこうかな

```
(define (last-pair l)
  (let ((m (cdr l)))
    (if (null? m)
        l
        (last-pair m))))
```

### Exercise 2.18. 

* リストを逆順にする手続きを定義せよ

appendとは反対で、繰り返しプロセスならすんなり書けます

`nil`はRacketでは定義されてないみたいでエラーになるので
`(quote ())`で書きました

```
(define (reverse l)
  (define (iter l ans)
    (if (null? l)
        ans
        (iter (cdr l) (cons (car l) ans))))
  (iter l (quote ()))
```

再帰プロセスで書くと力技感いっぱいなやり方しか思いつきません
なにもいいところがありません

```
(define (reverse-r l)
  (if (null? l)
      l
      (append (reverse-r (cdr l))
              (cons (car l) (quote ())))))
```

再帰プロセスで書けという問題ではありませんがさっきのappendのこともあるし
なにか関連付けて考えてほしいってことかなあと思いました

appendを繰り返しプロセスで書くのもやっぱり力技しか思いつかず
ふつうにやると逆順になるのであらかじめ逆順にしておきます

```
(define (append-i list1 list2)
  (define (iter l ans)
    (if (null? l)
        ans
        (iter (cdr l) (cons (car l) ans))))
  (iter (reverse list1) list2))
```

こっちはスタックを消費しないという意味がないでもない？
